# GraduateWork

Весь проект создан для обучения и не используется в коммерческих целях.

Этот проект содержит файлы ВКР. Тема ВКР - создание обучающей компьютерной игры с функциями речевого ввода.

Далее идет частичное описание ВКР.

Для реализации голосового ввода использовался PocketSphinxUnityDemo 

https://github.com/Funnyguy77/PocketSphinxUnityDemo

## 3.5	Игровая логика
Для дальнейшей игры пользователю требуется подойти к игровому персонажу «Собака» (рис. 3.5.1). Который имеет триггер для срабатывания определенной функции. На рисунке 3.5.2 зелеными линиями отмечен триггер.
Триггер – коллайдер, не имеющий коллизии который отвечает на определенные функции в скриптах. Тем самым при столкновении с любым объектом имеющий компонент rigibody объект будет проверятся на наличие определенного тега. Если объект имеет тег под названием «Player», то функция срабатывает и выполняется алгоритм выбора слов для произношения пользователем.


![image](https://github.com/Vetolisk/GraduateWork/assets/98349078/09843592-7656-4fd2-ba07-c454353deb15)


##  3.6	Алгоритм выбора слов для произношения пользователем
Создан класс, помогающий распределять слова в интерфейсе. Для того что бы пользователь получал разнообразие слов. 
Алгоритм реализован в классе WordsScript.cs.
Создается пустой список для заполнения слов. Случайным образом выбирается слово из списка заданных слов и заносится в пустой список. Далее проверяется если предыдущие слово совпадает со следующим из списка, то выбирается еще раз случайное слово, и так до заполнения списка. После того как пользователь вышел из триггера слова все удаляются для высвобождения памяти. На рисунке 3.6.1 представлен пример заданных слов для пользователя


![image](https://github.com/Vetolisk/GraduateWork/assets/98349078/a0e9db48-543f-440d-94a0-6965f62ad8b1)


UiTriggerWords.cs данный класс содержит в себе данные функции.
OnTriggerEnter() отвечающий за вхождение в триггер любого объекта.
OnTriggerExit() отвечающий за выход из триггера.
WordsScript.cs данный класс содержит в себе данные функции.
SetWords() создание слов в случайной последовательности.
ClearList() удаление слов из памяти. Для оптимизации приложения. 
Предлагаемые слова выбираются случайным образом из списка, всего 11 слов правильных и 11 слов неправильных. На рисунке 3.6.3 представлены слова. Из этих слов алгоритм выбирает случайно 6 слов и задает их в TextMeshProUGUI. TextMeshProUGUI это класс, отвечающий за отображение элемента в UI компонентах.


![image](https://github.com/Vetolisk/GraduateWork/assets/98349078/fbd7d762-9894-4e9f-b021-5789d46b0275)


При произношении определенного слова. Алгоритм распознает по транскрипции слово и перебирает по списку заданных слов если слово совпадает с заданным определением правильных слов, то слово окрашивается в нужный цвет в красный или зеленый, где зеленый это правильный ответ, а красный не правильный. Так же за правильное произнесенное слово, дается валюта под названием «Гнилая плоть», за нее можно обмениваться с торговцем на драгоценную валюту. На рисунке 3.6.1 приведен пример работы алгоритма.

![image](https://github.com/Vetolisk/GraduateWork/assets/98349078/aafbd317-bf35-423d-950e-35768e9378fa)


## 3.7	Разработка окна «Торговца»
В алгоритме используются данные классы:
Trader.cs
ManagerGame.cs
PlayerInteraction.cs
В классе Trader.cs содержатся методы.
Interact() взаимодействие игрока с данным объектом.
В классе ManagerGame.cs методы.
Trade() обмен производящий «гнилой плотью» на «изумруды» предметами.
Trade2() обмен производящий производящий «изумрудами» на «мясо».
В классе PlayerInteraction используется взаимодействие игрока с «Торговцем». При нажатии на клавишу E из камеры игрока отправляется невидимый луч, который при попадании в объект проверяет тэг объекта В классе trader вызывает функцию которая отображает панель торговца.
В классе ManaferGame функции Trade и Trade2 отвечают за обмен предметами. При нажатии на кнопку Trade проверяется наличии предметов у игрока и выдается определенное количество предмета указанного в панели «Торговца».
Окно торговца где можно обменять «гнилую плоть» на «изумруды», а «изумруды» обменять на «мясо». На рисунке 3.7.1 представлена панель торговли.


![image](https://github.com/Vetolisk/GraduateWork/assets/98349078/e133d806-c3a0-49c3-952f-e81a5e3c0f02)


## 3.8	Постройка деревни
Постройка деревни имеет определенный алгоритм, который использует определенные классы:
GameManagerHome.cs
BuyBuildManager.cs
Класс GameManagerHome сохраняет здания на сцене. И имеет методы.
Awake() инициализация переменных.
BuyBuildManager.cs имеет определенные методы такие как.
Start() инициализация объектов.
UpgradeVilagers() обновление объектов после нажатия кнопки то есть покупка.
За валюту можно отстраивать деревню. И наполнять ею жителями которые будут приносить валюту. На рисунке 3.8.1 отображено частичная постройка деревни.


![image](https://github.com/Vetolisk/GraduateWork/assets/98349078/8e39a251-8665-4df1-86e3-0e904a967188)


В классе BuyBuildManager написан алгоритм как происходит покупка постройки. На сцене уже присутствует все здании из деревни. На рисунке 3.8.2 задан список на сцене.

![image](https://github.com/Vetolisk/GraduateWork/assets/98349078/905df467-527e-457f-833c-f202a49d483a)


При загрузки сцены постройки деревни загружается валюта для торговли из файла. Далее при нажатии на кнопку срабатывает функция которая проверяет наличие валюты если больше или равняется заданной цене валюты то включается объект на сцене и повышается цена для следующей покупки жилья. И проходит дальше по списку.

## 3.9	Отсуствие пользователя и накопление валюты

Для увеличения продолжительности игры. Пользователю предоставляется возможность накапливать валюту отсуствием пользователя вне игры. Для этого используются определенные классы:
TimeSystem.cs
SaveSystem.cs
В классе TimeSystem используется данные с системного времени компьютера для отслеживания пользователя когда вышел и зашел на сцену.
В классе методы такие как. InitSingleton() единичная инициализация объекта. CheckOffline() проверка пользователя на сколько долго он  был не в сети.
 OnApplicationQuit() выход из сцены и сохранение данных.

С каждой минутой жители будут приносить дополнительную плату за проживание. Каждый житель приносить в минуту 1 «Изумруд». При выходе из этой сцены изумруды пополняются. Работа алгоритма. Работа со временем.
Входные параметры позволяют менять языковую модель алгоритма.
Было 15 «изумруда»  при посещении локации на рисунке 3.9.2.

![image](https://github.com/Vetolisk/GraduateWork/assets/98349078/2d77db9e-aa26-4188-b8cc-ace68830c430)


# Заключение
В результате выполнения выпускной квалификационной работы была разработана обучающая компьютерная игра с функциями речевого ввода, а также игровая логика взаимодействия элементов и управления с наглядным интерфейсом для игрока.
При этом было реализовано:
+	голосовое управление персонажем;
+	управление игроком;
+	работа алгоритма по распознаванию голоса;
+	работа сохранения данных в файловую систему;
+	игровой интерфейс;
+	работа со временем пользователя.

Получены навыки разработки на языке C# с применением принципов объектно ориентированного программирования, а также работа с игровым движком Unity и с встроенными библиотеками. Был изучена программа Blender работа с трехмерной графикой и импортированием файлов. Рассмотрены алгоритмы по распознаванию голосового управления.
